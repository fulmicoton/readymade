// Generated by CoffeeScript 1.3.3
(function() {
  var ROOT_PATH, Server, TEMPLATES, fs, http, jade, load_template_sync, mime, path, serve_directory_listing, serve_static_file, style, terminal,
    __slice = [].slice;

  style = require('../lib/style');

  http = require('http');

  fs = require('fs');

  path = require('path');

  mime = require('mime');

  jade = require('jade');

  path = require('path');

  terminal = require('color-terminal');

  ROOT_PATH = path.join(__dirname, '../');

  load_template_sync = function(rel_path) {
    var filepath, template_data;
    filepath = path.join(ROOT_PATH, rel_path);
    template_data = fs.readFileSync(filepath, 'utf-8');
    return jade.compile(template_data, {
      filename: filepath
    });
  };

  TEMPLATES = {
    directory_listing: load_template_sync('assets/directory_listing.jade'),
    error404: load_template_sync('assets/error404.jade')
  };

  serve_directory_listing = function(response, directory_path) {
    response.writeHead(404);
    return fs.readdir(directory_path, function(err, files) {
      var directory_listing;
      directory_listing = TEMPLATES.directory_listing({
        directory_path: directory_path,
        files: files
      });
      return response.end(directory_listing);
    });
  };

  serve_static_file = function(response, filepath) {
    var content_type, file, stat;
    try {
      if (fs.existsSync(filepath)) {
        stat = fs.statSync(filepath);
        if (stat.isDirectory()) {
          return serve_directory_listing(response, filepath);
        } else {
          content_type = mime.lookup(filepath);
          file = fs.createReadStream(filepath);
          file.pipe(response);
          return response.writeHead(200, {
            'content-type': content_type
          });
        }
      } else {
        response.writeHead(404);
        return response.end(TEMPLATES.error404({
          filepath: filepath
        }));
      }
    } catch (error) {
      response.writeHead(500);
      return response.end("Error " + error_msg);
    }
  };

  Server = (function() {

    function Server(options) {
      this.host = options.host;
      this.port = options.port;
      this.builder = options.builder;
      this.build_path = options.build_path;
    }

    Server.prototype.handle = function(request, response) {
      var failure_callback, rel_path, serve_file, url, url_base;
      response.setHeader("Access-Control-Allow-Origin", "*");
      url = request.url;
      url_base = url.split('?', 1)[0];
      rel_path = path.join(".", url_base);
      serve_file = function(target) {
        terminal.color(style.GET).write('GET   ').reset();
        terminal.color(style.TARGET).write(url).nl().reset();
        return serve_static_file(response, target);
      };
      failure_callback = function(target, error_msg) {
        if (typeof growl === "function") {
          growl(options.target + " build failed.");
        }
        terminal.color(style.ERROR).write('ERROR ');
        terminal.color(style.TARGET).write(url).nl().reset();
        terminal.right(2).color(style.TEXT).write(error_msg).nl().reset();
        response.writeHead(404);
        return response.end(TEMPLATES.error404({
          filepath: target,
          error_msg: error_msg
        }));
      };
      return this.builder.build(rel_path, serve_file, failure_callback);
    };

    Server.prototype.url = function() {
      return "http://" + this.host + ":" + this.port;
    };

    Server.prototype.run = function() {
      var server,
        _this = this;
      server = http.createServer(function() {
        var args;
        args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
        return _this.handle.apply(_this, args);
      });
      return server.listen(this.port, this.host);
    };

    return Server;

  })();

  module.exports = Server;

}).call(this);
